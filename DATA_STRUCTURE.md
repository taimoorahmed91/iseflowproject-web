# Data Structure Documentation - ISE Policy Visualizer

## Overview

The application consumes a single JSON file (`processed_data.json`) that contains all ISE policy configuration data. This file is generated by a Python processing script and stored in the GitHub repository.

**File Location:** `configs/processed_data.json`

**File Size:** Typically 50-200 KB

**Format:** JSON (UTF-8 encoded)

---

## Top-Level Structure

```json
{
  "metadata": { ... },
  "policy_sets": [ ... ],
  "reference_data": { ... }
}
```

### Metadata Object

Contains information about when and how the data was generated.

```json
{
  "metadata": {
    "generated_at": "2026-01-31T17:09:35.971764Z",
    "total_policy_sets": 3,
    "total_authentication_policies": 5,
    "total_authorization_policies": 14
  }
}
```

**Fields:**
- `generated_at` (string, ISO 8601 timestamp): When the processing script ran
- `total_policy_sets` (number): Count of policy sets in this configuration
- `total_authentication_policies` (number): Total auth policies across all sets
- `total_authorization_policies` (number): Total authz policies across all sets

**Usage:** Display in UI footer or metadata panel

---

## Policy Sets Array

Contains all policy sets in evaluation order.

```json
{
  "policy_sets": [
    {
      "id": "52a46a92-1525-480b-9b79-ca9db77e8ef8",
      "name": "PolicySet2",
      "description": "Sample 1",
      "rank": 0,
      "state": "enabled",
      "default": false,
      "condition": { ... },
      "serviceName": "Default Network Access",
      "isProxy": false,
      "link": { ... },
      "authentication_policies": [ ... ],
      "authorization_policies": [ ... ]
    }
  ]
}
```

### Policy Set Fields

**Identification:**
- `id` (string, UUID): Unique identifier from ISE
- `name` (string): Display name of the policy set
- `description` (string): Optional description

**Evaluation:**
- `rank` (number): Evaluation order (0 = first, higher = later)
- `state` (string): Either "enabled" or "disabled"
- `default` (boolean): Is this the default/catch-all policy set?

**Condition:**
- `condition` (object or null): Entry condition for this policy set
  - If null: Always matches (typical for default policy set)
  - If object: See Condition Structure section

**Metadata:**
- `serviceName` (string): ISE service name (usually "Default Network Access")
- `isProxy` (boolean): Whether this is a proxy policy set
- `link` (object): API URL reference (not used in visualization)

**Nested Policies:**
- `authentication_policies` (array): See Authentication Policy section
- `authorization_policies` (array): See Authorization Policy section

### Evaluation Logic

Policy sets are evaluated in order by `rank`:

1. Check condition of policy set with rank=0
   - Match? Enter this policy set, evaluate its policies
   - No match? Try rank=1
2. Check condition of policy set with rank=1
   - Match? Enter this policy set
   - No match? Try rank=2
3. Continue until a match or reach default policy set

**Default policy set:**
- Always has `condition: null`
- Always matches (catch-all)
- Typically has highest rank number

---

## Condition Structure

Conditions define when a policy or policy set matches. They can be simple or compound (AND/OR blocks).

### Simple Condition

```json
{
  "conditionType": "ConditionAttributes",
  "isNegate": false,
  "dictionaryName": "Normalised Radius",
  "attributeName": "RadiusFlowType",
  "operator": "equals",
  "attributeValue": "Wireless802_1x"
}
```

**OR**

```json
{
  "conditionType": "LibraryConditionAttributes",
  "isNegate": false,
  "dictionaryName": "Normalised Radius",
  "attributeName": "RadiusFlowType",
  "operator": "equals",
  "attributeValue": "Wireless802_1x",
  "name": "Wireless_802.1X",
  "id": "caf94e42-41dc-4919-a457-d4bba92646b6",
  "description": "A condition to match 802.1X based...",
  "link": { ... }
}
```

**Difference:**
- `ConditionAttributes`: Inline condition
- `LibraryConditionAttributes`: Condition from ISE library (has name, id, description)

**Fields:**
- `conditionType` (string): Type of condition
- `isNegate` (boolean): If true, negate the result (NOT)
- `dictionaryName` (string): ISE dictionary (e.g., "Normalised Radius", "Network Access")
- `attributeName` (string): Attribute to check (e.g., "RadiusFlowType", "EapAuthentication")
- `operator` (string): Comparison operator (equals, contains, startsWith, etc.)
- `dictionaryValue` (string or null): Reference to another dictionary (usually null)
- `attributeValue` (string): Value to compare against

**Display Format:**
```
Normalised Radius.RadiusFlowType EQUALS Wireless802_1x
```

### AND Block Condition

```json
{
  "conditionType": "ConditionAndBlock",
  "isNegate": false,
  "children": [
    {
      "conditionType": "LibraryConditionAttributes",
      "dictionaryName": "Network Access",
      "attributeName": "AuthenticationStatus",
      "operator": "equals",
      "attributeValue": "AuthenticationPassed",
      ...
    },
    {
      "conditionType": "LibraryConditionAttributes",
      "dictionaryName": "Session",
      "attributeName": "PostureStatus",
      "operator": "equals",
      "attributeValue": "Compliant",
      ...
    }
  ]
}
```

**Logic:** ALL children conditions must be true

**Display Format:**
```
(Network Access.AuthenticationStatus EQUALS AuthenticationPassed)
AND
(Session.PostureStatus EQUALS Compliant)
```

### OR Block Condition

```json
{
  "conditionType": "ConditionOrBlock",
  "isNegate": false,
  "children": [
    {
      "conditionType": "LibraryConditionAttributes",
      "dictionaryName": "Normalised Radius",
      "attributeName": "RadiusFlowType",
      "operator": "equals",
      "attributeValue": "WiredMAB",
      ...
    },
    {
      "conditionType": "LibraryConditionAttributes",
      "dictionaryName": "Normalised Radius",
      "attributeName": "RadiusFlowType",
      "operator": "equals",
      "attributeValue": "WirelessMAB",
      ...
    }
  ]
}
```

**Logic:** ANY child condition can be true

**Display Format:**
```
(Normalised Radius.RadiusFlowType EQUALS WiredMAB)
OR
(Normalised Radius.RadiusFlowType EQUALS WirelessMAB)
```

### Nested Conditions

AND/OR blocks can be nested:

```json
{
  "conditionType": "ConditionAndBlock",
  "children": [
    {
      "conditionType": "ConditionOrBlock",
      "children": [ ... ]
    },
    {
      "conditionType": "LibraryConditionAttributes",
      ...
    }
  ]
}
```

**Display Format:**
```
( (Condition A) OR (Condition B) )
AND
(Condition C)
```

---

## Authentication Policies

Located in: `policy_sets[].authentication_policies[]`

Sorted by `rank` within each policy set.

```json
{
  "rule": {
    "id": "12c8665b-7764-4a0c-8e0e-774e68ba4a0d",
    "name": "MAB",
    "rank": 0,
    "state": "enabled",
    "default": false,
    "condition": { ... }
  },
  "identitySourceName": "Internal Endpoints",
  "ifAuthFail": "REJECT",
  "ifUserNotFound": "CONTINUE",
  "ifProcessFail": "DROP",
  "link": { ... }
}
```

### Rule Object

- `id` (string, UUID): Unique identifier
- `name` (string): Policy name
- `rank` (number): Evaluation order within this policy set
- `state` (string): "enabled" or "disabled"
- `default` (boolean): Is this the default auth policy?
- `condition` (object or null): Match condition

### Authentication Results

- `identitySourceName` (string): Which identity source to use
  - Examples: "Internal Endpoints", "Active Directory", "All_User_ID_Stores"

- `ifAuthFail` (string): What to do if authentication fails
  - Options: "REJECT", "CONTINUE", "DROP"
  
- `ifUserNotFound` (string): What to do if user not found
  - Options: "REJECT", "CONTINUE", "DROP"
  
- `ifProcessFail` (string): What to do if process fails
  - Options: "REJECT", "CONTINUE", "DROP"

### Evaluation Flow

Authentication policies are evaluated in sequence by `rank`:

1. Check condition of first policy (rank=0)
   - Match? Use this policy's result
   - No match? Try next policy
2. If result is "CONTINUE":
   - Proceed to authorization policies
3. If result is "REJECT" or "DROP":
   - Access denied, stop here

**Important:** Authorization policies ONLY run if authentication returns "CONTINUE"

---

## Authorization Policies

Located in: `policy_sets[].authorization_policies[]`

Sorted by `rank` within each policy set.

```json
{
  "rule": {
    "id": "525786dd-e844-4d1f-a91e-a7bf772e1d42",
    "name": "Wireless Block List Default",
    "rank": 0,
    "state": "enabled",
    "default": false,
    "condition": { ... }
  },
  "profile": ["Block_Wireless_Access"],
  "securityGroup": null,
  "link": { ... }
}
```

### Rule Object

Same as authentication policies:
- `id`, `name`, `rank`, `state`, `default`, `condition`

### Authorization Results

- `profile` (array of strings): Authorization profile name(s) to apply
  - Examples: ["PermitAccess"], ["Cisco_IP_Phones"], ["DenyAccess"]
  - Can be multiple profiles
  - Names reference `reference_data.authorization_profiles`

- `securityGroup` (string or null): Security Group Tag (SGT) to assign
  - Examples: "BYOD", "Guests", "Employees", null

### Evaluation Flow

Authorization policies are evaluated in sequence by `rank`:

1. Check condition of first policy (rank=0)
   - Match? Apply this policy's profile(s) and SGT
   - No match? Try next policy
2. Check condition of second policy (rank=1)
   - Continue until a match
3. Always ends with default policy (matches everything)

---

## Reference Data

Contains lookup information for profiles, ACLs, and protocols.

```json
{
  "reference_data": {
    "authorization_profiles": { ... },
    "authorization_profiles_detail": { ... },
    "downloadable_acls": { ... },
    "allowed_protocols": { ... },
    "allowed_protocols_detail": { ... }
  }
}
```

### Authorization Profiles (Basic)

Quick lookup for profile names.

```json
{
  "authorization_profiles": {
    "PermitAccess": {
      "id": "6eed36e0-8bff-11e6-996c-525400b48521",
      "name": "PermitAccess",
      "description": "Default Profile with access type as Access-Accept",
      "link": { ... }
    },
    "DenyAccess": {
      "id": "6ef23ff0-8bff-11e6-996c-525400b48521",
      "name": "DenyAccess",
      "description": "Default Profile with access type as Access-Reject",
      "link": { ... }
    }
  }
}
```

**Indexed by:** Profile name AND profile ID (both keys point to same object)

**Usage:** Quick name → description lookup for flowchart tooltips

### Authorization Profiles (Detailed)

Full profile configuration.

```json
{
  "authorization_profiles_detail": {
    "PermitAccess": {
      "id": "6eed36e0-8bff-11e6-996c-525400b48521",
      "name": "PermitAccess",
      "description": "Default Profile with access type as Access-Accept",
      "accessType": "ACCESS_ACCEPT",
      "authzProfileType": "SWITCH",
      "trackMovement": false,
      "agentlessPosture": false,
      "serviceTemplate": false,
      "easywiredSessionCandidate": false,
      "link": { ... }
    },
    "Cisco_IP_Phones": {
      "id": "982ef910-8c01-11e6-996c-525400b48521",
      "name": "Cisco_IP_Phones",
      "description": "Default profile used for Cisco Phones.",
      "accessType": "ACCESS_ACCEPT",
      "authzProfileType": "SWITCH",
      "daclName": "PERMIT_ALL_IPV4_TRAFFIC",
      "voiceDomainPermission": true,
      "trackMovement": false,
      "agentlessPosture": false,
      "serviceTemplate": false,
      "easywiredSessionCandidate": false,
      "profileName": "Cisco",
      "link": { ... }
    },
    "Cisco_WebAuth": {
      "id": "9859b290-8c01-11e6-996c-525400b48521",
      "name": "Cisco_WebAuth",
      "description": "Default Profile used to redirect users to the CWA portal.",
      "accessType": "ACCESS_ACCEPT",
      "authzProfileType": "SWITCH",
      "webRedirection": {
        "WebRedirectionType": "CentralizedWebAuth",
        "acl": "ACL_WEBAUTH_REDIRECT",
        "portalName": "Self-Registered Guest Portal (default)",
        "displayCertificatesRenewalMessages": false
      },
      "trackMovement": false,
      "agentlessPosture": false,
      "serviceTemplate": false,
      "easywiredSessionCandidate": false,
      "profileName": "Cisco",
      "link": { ... }
    }
  }
}
```

**Key Fields:**
- `accessType`: "ACCESS_ACCEPT" or "ACCESS_REJECT"
- `daclName`: Downloadable ACL name (if applicable)
- `webRedirection`: Web redirect configuration (if applicable)
- `voiceDomainPermission`: Voice VLAN access (for IP phones)
- `advancedAttributes`: Additional RADIUS attributes (for advanced profiles)

**Usage:** Display in detail sidebar when user clicks on authorization result

### Downloadable ACLs

```json
{
  "downloadable_acls": {
    "PERMIT_ALL_IPV4_TRAFFIC": {
      "id": "982498d0-8c01-11e6-996c-525400b48521",
      "name": "PERMIT_ALL_IPV4_TRAFFIC",
      "description": "Allow all ipv4 Traffic",
      "link": { ... }
    }
  }
}
```

**Usage:** Reference when showing profile details that use a DACL

### Allowed Protocols (Basic)

```json
{
  "allowed_protocols": {
    "Default Network Access": {
      "id": "92613980-8c01-11e6-996c-525400b48521",
      "name": "Default Network Access",
      "description": "Default Allowed Protocol Service",
      "link": { ... }
    }
  }
}
```

### Allowed Protocols (Detailed)

```json
{
  "allowed_protocols_detail": {
    "Default Network Access": {
      "id": "92613980-8c01-11e6-996c-525400b48521",
      "name": "Default Network Access",
      "description": "Default Allowed Protocol Service",
      "processHostLookup": true,
      "allowPapAscii": true,
      "allowChap": false,
      "allowMsChapV1": false,
      "allowMsChapV2": false,
      "allowEapMd5": true,
      "allowLeap": false,
      "allowEapTls": true,
      "allowEapTtls": true,
      "allowEapFast": true,
      "allowPeap": true,
      "allowTeap": true,
      "eapTls": { ... },
      "peap": { ... },
      "eapFast": { ... },
      "eapTtls": { ... },
      "teap": { ... },
      "link": { ... }
    }
  }
}
```

**Usage:** Show which authentication protocols are allowed (for advanced users)

---

## Data Validation

### Required Fields

**Top-level:**
- `metadata` (object, required)
- `policy_sets` (array, required, min length: 1)
- `reference_data` (object, required)

**Policy Set:**
- `id` (string, required)
- `name` (string, required)
- `rank` (number, required)
- `state` (string, required, must be "enabled" or "disabled")
- `default` (boolean, required)
- `condition` (object or null, required)
- `authentication_policies` (array, required)
- `authorization_policies` (array, required)

**Policy (Auth/Authz):**
- `rule` (object, required)
- `rule.id` (string, required)
- `rule.name` (string, required)
- `rule.rank` (number, required)

### Data Integrity

**Ranks must be unique:**
- Within policy sets: Each policy set must have unique rank
- Within policies: Each policy within a set must have unique rank

**Exactly one default policy set:**
- One policy set must have `default: true`
- All others must have `default: false`

**Conditions:**
- If `conditionType` is "ConditionAndBlock" or "ConditionOrBlock":
  - Must have `children` array
  - `children` must not be empty
- If `conditionType` is "ConditionAttributes" or "LibraryConditionAttributes":
  - Must have `dictionaryName`, `attributeName`, `operator`, `attributeValue`

---

## Example: Complete Small Configuration

```json
{
  "metadata": {
    "generated_at": "2026-01-31T18:00:00Z",
    "total_policy_sets": 1,
    "total_authentication_policies": 1,
    "total_authorization_policies": 2
  },
  "policy_sets": [
    {
      "id": "policy-set-1",
      "name": "Default",
      "description": "Default policy set",
      "rank": 0,
      "state": "enabled",
      "default": true,
      "condition": null,
      "serviceName": "Default Network Access",
      "isProxy": false,
      "authentication_policies": [
        {
          "rule": {
            "id": "auth-1",
            "name": "Default Auth",
            "rank": 0,
            "state": "enabled",
            "default": true,
            "condition": null
          },
          "identitySourceName": "All_User_ID_Stores",
          "ifAuthFail": "REJECT",
          "ifUserNotFound": "REJECT",
          "ifProcessFail": "DROP"
        }
      ],
      "authorization_policies": [
        {
          "rule": {
            "id": "authz-1",
            "name": "Authenticated Access",
            "rank": 0,
            "state": "enabled",
            "default": false,
            "condition": {
              "conditionType": "LibraryConditionAttributes",
              "isNegate": false,
              "dictionaryName": "Network Access",
              "attributeName": "AuthenticationStatus",
              "operator": "equals",
              "attributeValue": "AuthenticationPassed",
              "name": "Network_Access_Authentication_Passed",
              "id": "condition-1",
              "description": "Default condition for authentication passed"
            }
          },
          "profile": ["PermitAccess"],
          "securityGroup": null
        },
        {
          "rule": {
            "id": "authz-2",
            "name": "Default Deny",
            "rank": 1,
            "state": "enabled",
            "default": true,
            "condition": null
          },
          "profile": ["DenyAccess"],
          "securityGroup": null
        }
      ]
    }
  ],
  "reference_data": {
    "authorization_profiles": {
      "PermitAccess": {
        "id": "profile-1",
        "name": "PermitAccess",
        "description": "Allow access"
      },
      "DenyAccess": {
        "id": "profile-2",
        "name": "DenyAccess",
        "description": "Deny access"
      }
    },
    "authorization_profiles_detail": {
      "PermitAccess": {
        "id": "profile-1",
        "name": "PermitAccess",
        "description": "Allow access",
        "accessType": "ACCESS_ACCEPT",
        "authzProfileType": "SWITCH"
      },
      "DenyAccess": {
        "id": "profile-2",
        "name": "DenyAccess",
        "description": "Deny access",
        "accessType": "ACCESS_REJECT",
        "authzProfileType": "SWITCH"
      }
    },
    "downloadable_acls": {},
    "allowed_protocols": {},
    "allowed_protocols_detail": {}
  }
}
```

---

## Processing Tips for Developers

### Loading Strategy

1. Fetch JSON from GitHub
2. Parse with `JSON.parse()`
3. Validate structure (check required fields)
4. Store in state/context
5. Pre-process for rendering:
   - Index profiles by name for quick lookup
   - Sort policy sets by rank
   - Sort policies within sets by rank

### Rendering Conditions

**Recursive function needed:**

```typescript
function renderCondition(condition: Condition): string {
  if (!condition) return "(always matches)";
  
  if (condition.conditionType === "ConditionAttributes" ||
      condition.conditionType === "LibraryConditionAttributes") {
    return `${condition.dictionaryName}.${condition.attributeName} ${condition.operator.toUpperCase()} ${condition.attributeValue}`;
  }
  
  if (condition.conditionType === "ConditionAndBlock") {
    const childrenText = condition.children.map(c => renderCondition(c)).join(" AND ");
    return `(${childrenText})`;
  }
  
  if (condition.conditionType === "ConditionOrBlock") {
    const childrenText = condition.children.map(c => renderCondition(c)).join(" OR ");
    return `(${childrenText})`;
  }
  
  return "(unknown condition type)";
}
```

### Displaying Results

**For Authentication:**
```
Result: Continue
• If Auth Fail: REJECT
• If User Not Found: CONTINUE
• If Process Fail: DROP
```

**For Authorization:**
```
Profile: PermitAccess
Security Group: BYOD

[Click for Details] ← Opens sidebar with full profile info
```

---

## Common Scenarios

### Scenario 1: Simple Policy Set

- One policy set (Default)
- One auth policy (always matches)
- Two authz policies:
  - First: Check if authenticated → PermitAccess
  - Default: DenyAccess

### Scenario 2: Multiple Policy Sets

- Policy Set 1: For wireless (rank 0)
  - Condition: Wireless_802.1X
  - Complex auth/authz policies
- Policy Set 2: For wired (rank 1)
  - Condition: Wired_802.1X
  - Different auth/authz policies
- Default Policy Set (rank 2)
  - Condition: null (always matches)
  - Simple deny-all policy

### Scenario 3: Complex Conditions

- AND block with multiple conditions
- OR blocks nested inside AND blocks
- Library conditions referenced by ID
- Conditions with negation (isNegate: true)

---

## Troubleshooting Data Issues

### Empty Arrays

**If `authentication_policies` is empty:**
- This is unusual but valid
- Display: "No authentication policies configured"
- May indicate policy set is disabled or being configured

**If `authorization_policies` is empty:**
- This is unusual but valid
- Display: "No authorization policies configured"
- Access will likely be denied by default

### Missing Reference Data

**If profile referenced but not in `authorization_profiles_detail`:**
- Display profile name only
- Show warning: "Profile details not available"
- Don't crash, graceful degradation

### Malformed Conditions

**If condition has unknown `conditionType`:**
- Display: "(unknown condition type)"
- Log warning to console
- Continue processing other policies

---

## TypeScript Interfaces

For reference, here are recommended TypeScript types:

```typescript
interface ProcessedData {
  metadata: Metadata;
  policy_sets: PolicySet[];
  reference_data: ReferenceData;
}

interface Metadata {
  generated_at: string;
  total_policy_sets: number;
  total_authentication_policies: number;
  total_authorization_policies: number;
}

interface PolicySet {
  id: string;
  name: string;
  description: string;
  rank: number;
  state: "enabled" | "disabled";
  default: boolean;
  condition: Condition | null;
  serviceName: string;
  isProxy: boolean;
  link: Link;
  authentication_policies: AuthenticationPolicy[];
  authorization_policies: AuthorizationPolicy[];
}

interface Condition {
  conditionType: "ConditionAttributes" | "LibraryConditionAttributes" | 
                 "ConditionAndBlock" | "ConditionOrBlock";
  isNegate: boolean;
  // Simple condition fields
  dictionaryName?: string;
  attributeName?: string;
  operator?: string;
  dictionaryValue?: string | null;
  attributeValue?: string;
  // Library condition fields
  name?: string;
  id?: string;
  description?: string;
  link?: Link;
  // Block condition fields
  children?: Condition[];
}

interface AuthenticationPolicy {
  rule: PolicyRule;
  identitySourceName: string;
  ifAuthFail: "REJECT" | "CONTINUE" | "DROP";
  ifUserNotFound: "REJECT" | "CONTINUE" | "DROP";
  ifProcessFail: "REJECT" | "CONTINUE" | "DROP";
  link: Link;
}

interface AuthorizationPolicy {
  rule: PolicyRule;
  profile: string[];
  securityGroup: string | null;
  link: Link;
}

interface PolicyRule {
  id: string;
  name: string;
  rank: number;
  state: "enabled" | "disabled";
  default: boolean;
  condition: Condition | null;
}

interface Link {
  rel: string;
  href: string;
  type: string;
}

interface ReferenceData {
  authorization_profiles: Record<string, AuthorizationProfile>;
  authorization_profiles_detail: Record<string, AuthorizationProfileDetail>;
  downloadable_acls: Record<string, DownloadableAcl>;
  allowed_protocols: Record<string, AllowedProtocol>;
  allowed_protocols_detail: Record<string, AllowedProtocolDetail>;
}

// ... (additional interfaces for reference data objects)
```